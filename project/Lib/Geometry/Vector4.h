#pragma once

//-----------------------------------------------------------------------------------------
// include
//-----------------------------------------------------------------------------------------
//* lib
#include <Lib/Sxl/Formatter.h>

//* c++
#include <concepts>

////////////////////////////////////////////////////////////////////////////////////////////
// Vector4 class
////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
class Vector4 {
public:

	//=========================================================================================
	// constructor
	//=========================================================================================

	constexpr Vector4() = default;
	constexpr Vector4(T _x, T _y, T _z) : x(_x), y(_y), z(_z), w(1.0f) {}
	constexpr Vector4(T _x, T _y, T _z, T _w) : x(_x), y(_y), z(_z), w(_w) {}

	//=========================================================================================
	// variables
	//=========================================================================================

	T x, y, z, w;

	//=========================================================================================
	// formatter
	//=========================================================================================

	template <typename FormatContext>
	auto format(FormatContext& ctx) const {
		return std::format_to(ctx.out(), "(x: {}, y: {}, z: {}, w: {})", x, y, z, w);
	}

};

////////////////////////////////////////////////////////////////////////////////////////////
// formatter
////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
struct std::formatter<Vector4<T>> : Sxl::BaseFormatter<Vector4<T>> {};

//-----------------------------------------------------------------------------------------
// using
//-----------------------------------------------------------------------------------------

using Vector4f = Vector4<float>;
using Vector4i = Vector4<int32_t>;

////////////////////////////////////////////////////////////////////////////////////////////
// Color4 class
////////////////////////////////////////////////////////////////////////////////////////////
template <typename T>
concept ColorT = std::same_as<T, int> || std::same_as<T, float>;
//!< intまたはfloatのみを使用

template <ColorT T>
class Color4 { //!< Vector4の継承でやりたい
public:

	//=========================================================================================
	// constructor
	//=========================================================================================

	constexpr Color4() = default;
	constexpr Color4(T _r, T _g, T _b, T _a) : r(_r), g(_g), b(_b), a(_a) {}

	//=========================================================================================
	// variables
	//=========================================================================================
	
	union {
		T x, r;
	};

	union {
		T y, g;
	};

	union {
		T z, b;
	};

	union {
		T w, a;
	};

	//=========================================================================================
	// operator
	//=========================================================================================

	constexpr bool operator==(const Color4<T>& other) const {
		return r == other.r && g == other.g && b == other.b && a == other.a;
	}

	//=========================================================================================
	// formatter
	//=========================================================================================

	template <typename FormatContext>
	auto format(FormatContext& ctx) const {
		return std::format_to(ctx.out(), "(r: {}, g: {}, b: {}, a: {})", r, g, b, a);
	}

};

////////////////////////////////////////////////////////////////////////////////////////////
// formatter
////////////////////////////////////////////////////////////////////////////////////////////
template <class T>
struct std::formatter<Color4<T>> : Sxl::BaseFormatter<Color4<T>> {};

//-----------------------------------------------------------------------------------------
// using
//-----------------------------------------------------------------------------------------

using Color4f = Color4<float>;
using Color4i = Color4<int32_t>;

//-----------------------------------------------------------------------------------------
// constexpr
//-----------------------------------------------------------------------------------------

constexpr const Color4f kWhite4 = { 1.0f, 1.0f, 1.0f, 1.0f };

//-----------------------------------------------------------------------------------------
// methods
//-----------------------------------------------------------------------------------------

constexpr Color4<int32_t> ToColor4i(const Color4<float>& color) {
	return { static_cast<int32_t>(color.r * 255.0f), static_cast<int32_t>(color.g * 255.0f), static_cast<int32_t>(color.b * 255.0f), static_cast<int32_t>(color.a * 255.0f) };
}

constexpr Color4<float> ToColor4f(const Color4<int32_t>& color) {
	return { color.r / 255.0f, color.g / 255.0f, color.b / 255.0f, color.a / 255.0f };
}

constexpr Color4<float> ToColor4f(const uint32_t colorCode) {
	return {
		((colorCode >> (8 * 3)) & 0xFF) / 255.0f, // r
		((colorCode >> (8 * 2)) & 0xFF) / 255.0f, // g
		((colorCode >> (8 * 1)) & 0xFF) / 255.0f, // b
		((colorCode >> (8 * 0)) & 0xFF) / 255.0f  // a
	};
}


